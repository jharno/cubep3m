!! :: cubepm parameter file

!! Frequently changed parameters are found in this header file:

include '../parameters'

!! files / paths 

character(*), parameter :: checkpoints=cubepm_root//'input/checkpoints'
character(*), parameter :: projections=cubepm_root//'input/projections'
character(*), parameter :: halofinds=  cubepm_root//'input/halofinds'
character(*), parameter :: kernel_path=cubepm_root//'kernels/'

!! cosmological parameters

! turn this off for pair-wise force tests

logical, parameter 	:: cosmo = .true. !.false.

! equation of state for dark energy w parameter

real(4), parameter      :: wde = -1.0 

! timestep parameters

real(4), parameter      :: dt_scale = 1.0
real(4), parameter 	:: dt_max = 1.0
real(4), parameter 	:: ra_max = 0.05
real(4), parameter 	:: da_max = 0.01
real(4), parameter      :: a_i = 1.0 / ( z_i + 1.0)
real(4), parameter      :: cfactor = 1.05

!! initial and final conditions

! maximum number of timesteps (in case simulation runs off on us)

integer(4), parameter   :: max_nts = 4000

! if we are going to restart a simulation, set to true and
! specify which checkpoint to restart from

!for 'cold' start:

logical, parameter	:: restart_ic =  .false.   
integer(4), parameter   :: restart_checkpoint = 1

!for restart: 

!logical, parameter	:: restart_ic =  .true.
!integer(4), parameter   :: restart_checkpoint = 1

! other internal initial conditions for testing, if all ic flags are
! set .false. cubepm assumes it is starting with initial conditions
! from dist_init

logical, parameter      :: random_ic   = .false.
logical, parameter      :: grid_ic     = .false.
logical, parameter      :: pairwise_ic = .false. !.true. 
logical, parameter      :: pair_infall = .false.
logical, parameter      :: pair_infall_no_shake = .false.
logical, parameter      :: pp_test     = .false.
logical, parameter      :: shake_test_ic = .false.
real, parameter         :: pair_infall_mass = 1000
real, parameter         :: pair_infall_sep  = 2.0
real, parameter         :: min_sep=0.0 !10
real, parameter         :: max_sep=3.0 !20 !nf_buf !2.0 !1
real, parameter         :: sep_inc=0.1

!! particle-particle interaction parameters

! softening length (if (|r1-r2| < rsoft) then no force)
real(4), parameter      :: rsoft = 0.1 !0.02
! arbitrary timescale limiting parameter :: dt_max_pp=sqrt(dt_pp_scale*rsoft/max_pp_acceleration)
real(4), parameter      :: dt_pp_scale = 0.05
! arbitrary pp bias (set to increase the force interaction)
real(4), parameter      :: pp_bias = 1.0 !0.85 !0.1 !0.4642

! testing flags

logical, parameter :: ngp_fmesh_force = .true. 
logical, parameter :: pp_force_flag = .true.
logical, parameter :: coarse_vel_update = .true.

!! additional simulation analysis

! set this .true. to generate coarse mesh mass power spectrum each timestep

logical, parameter      :: coarse_ps = .true. ! .false.

! halo finding parameters

! write out entire halo catalog, or just the value of nhalo

logical, parameter      :: halo_write = .true.

! spherical overdensity cutoff for determining halo extent

real(4), parameter      :: halo_odc=178.0
real(4), parameter      :: halo_nondim_mass=53.92 !nondim. mass corresponding
                                                  !to this overdensity
						  !according to TIS+1/r^2
						  !model. Look into
						  !'table_M_Delta.dat' to
						  !determine for a different
						  !overdensity.
real(4)		        :: actual_odc				 

!search radius for locating a density peak

real(4)        	   	:: r_soft_peak = 3.0*rsoft	

integer(4), parameter :: finer_halo_grid = 1 !3 !by what factor to make the fine grid
                                             !finer for the halo finding

! lower density peak threshold for determining which peaks should be inspected
! as halos

real(4), parameter      :: den_peak_cutoff = 100.
	!2.5 particles in a fine cell if halo is in the corner -> 20 particles 
	!peaks should be all picked-up? - no

! lower mass cutoff for cataloging a halo, in particles

real(4), parameter      :: min_halo_particles = 20.0

! set .true. to use parabolic interpolation for halo centers, otherwise
! nearest grid point is used

logical, parameter      :: para_inter_hc = .true.

! set .true. to limit initial halo mass calculation to exiting after only
! completing an entire radial shell

logical, parameter      :: complete_shell = .true.

! these are internal and should not be modified

integer(4), parameter   :: nc_halo_max = 128 !32
integer(4), parameter   :: nlist=(nc_halo_max+1)**3*5
integer(4), parameter   :: max_maxima= nc_halo_max**3!*10 !note: max number of the (local)
                                                        !density maxima, set to ~0.3 million
integer(4), parameter	:: max_bins = floor(real(nf_buf)/rsoft)+1   
	    		   ! in how many radial bins to bin the halo mass around each peak 

!! physical constants

real(4), parameter :: pi = 3.141592654
real(4), parameter :: G = 1.0 / 6.0 / pi
real(4), parameter :: eps = 1.0e-03

! :: internal parameters

logical, parameter :: forward = .true.
logical, parameter :: backward= .false.

integer(4), parameter   :: mesh_scale = 4
integer(4), parameter   :: coarsened_velocity_scale = mesh_scale
!integer(4), parameter   :: fine_clumping_scale = 8
integer(4), parameter   :: fine_clumping_scale = mesh_scale!*finer_halo_grid 
				!this makes velocity and fine clumping 
	                        !coarse output at the same resolution as 
                                !the coarse mesh cic density field

integer(4), parameter   :: coarsest_scale = 4 !by what factor to coarsen the output 
                                              !down from the coarse grid resolution
	
        
integer(4), parameter :: max_np = density_buffer * ( ((nf_tile-2*nf_buf)*tiles_node_dim/2)**3 + &
                                  (8*nf_buf**3 + 6*nf_buf*(((nf_tile-2*nf_buf)*tiles_node_dim)**2) + &
                                  12*(nf_buf**2)*((nf_tile-2*nf_buf)*tiles_node_dim))/8.0 )

integer(4), parameter   :: max_buf = 2 * max_np  !+ (nf_tile/2)**3 
integer(4), parameter   :: max_tag = max_np / 10

! this can probably be decreased like mega
!integer(4), parameter :: max_llf = ( (nf_tile * tiles_node_dim) / 2 )**2 / mesh_scale 
!integer(4), parameter :: max_llf = 120*( (nf_tile * tiles_node_dim) / 2 )**2 / mesh_scale 
integer(4), parameter :: max_llf = 100000 

integer(4), parameter   :: max_input = 100
integer(4), parameter   :: max_path = 100

integer(4), parameter   :: nodes = nodes_dim * nodes_dim * nodes_dim
integer(4), parameter   :: tiles_node = tiles_node_dim * tiles_node_dim &
                                      * tiles_node_dim

integer(4), parameter   :: nc_buf = nf_buf / mesh_scale

integer(4), parameter   :: nc_tile_dim = ( nf_tile - 2 * nf_buf ) / mesh_scale
integer(4), parameter   :: nc_node_dim = nc_tile_dim * tiles_node_dim
integer(4), parameter   :: nc_dim = nc_node_dim * nodes_dim

integer(4), parameter   :: nodes_slab = nodes_dim * nodes_dim
integer(4), parameter   :: nc_slab = nc_dim / nodes

integer(4), parameter   :: nf_physical_tile_dim = nf_tile - 2 * nf_buf
integer(4), parameter   :: nf_physical_dim = nf_physical_tile_dim &
                                           * tiles_node_dim * nodes_dim
integer(4), parameter   :: nf_physical_node_dim = nf_physical_tile_dim &
                                                * tiles_node_dim

integer(4), parameter   :: hoc_nc_l = 1 - nc_buf
integer(4), parameter   :: hoc_nc_h = nc_node_dim &
                                    + nc_buf
integer(4), parameter   :: hoc_pass_depth = 2 * nc_buf


!Changed: special for halo finding only!! 
!Make special versions of the mesh parameters using finer_halo_grid

!       this makes nf_physical_tile_dim_halos larger than nf_physical_tile_dim 
!	by a factor of finer_halo_grid

!note: buffer region is the same size, but has finer_halo_grid more cells due to the finer resulution for halo finding
integer(4), parameter   :: nf_buf_halos=nf_buf*finer_halo_grid 

integer(4), parameter   :: nf_tile_halos=finer_halo_grid*nf_tile
!integer(4), parameter   :: nc_tile_dim_halos=( nf_tile_halos - 2 * nf_buf ) / mesh_scale
integer(4), parameter   :: nf_physical_tile_dim_halos = nf_tile_halos - 2 * nf_buf_halos

real(4), dimension(3,nc_dim+2,nc_dim,nc_slab)                           :: tmp_kern_c


