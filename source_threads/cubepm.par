!! Frequently changed parameters are found in this header file:

include '../parameters'

!! files / paths 

character(*), parameter :: checkpoints=cubepm_root//'input/checkpoints'
character(*), parameter :: projections=cubepm_root//'input/projections'!_Lensing'
character(*), parameter :: halofinds=  cubepm_root//'input/halofinds'!_Lensing'
character(*), parameter :: kernel_path=cubepm_root//'kernels/'

!! cosmological parameters

! turn this off for pair-wise force tests
logical, parameter 	:: cosmo = .true.

! equation of state for dark energy w parameter

real(4), parameter      :: wde = -1.0 
real(4), parameter      :: w_a = 0.0
real(4), parameter      :: alpha_ch = 0
real(4), parameter      :: A_ch = 1

! timestep parameters

real(4), parameter      :: dt_scale = 1.0
real(4), parameter 	:: dt_max = 1.0
real(4), parameter 	:: ra_max = 0.05
real(4), parameter 	:: da_max = 0.01
real(4), parameter      :: a_i = 1.0 / ( z_i + 1.0)
real(4), parameter      :: cfactor = 1.05

!! initial and final conditions

! maximum number of timesteps (in case simulation runs off on us)

integer(4), parameter   :: max_nts = 4000

! if we are going to restart a simulation, set to true and
! specify which checkpoint to restart from

!for 'cold' start:
!logical, parameter	:: restart_ic =  .false.   
!integer(4), parameter   :: restart_checkpoint = 1

!for restart:

logical, parameter	:: restart_ic =  .false.
integer(4), parameter   :: restart_checkpoint = 1 ! line number in input/checkpoint 

! To restart from a checkpoint kill compile with CHECKPOINT_KILL and set restart_kill = .true.
logical, parameter :: restart_kill = .false. 
character(*), parameter :: reskill_prefix = '0.000'

! other internal initial conditions for testing, if all ic flags are
! set .false. cubepm assumes it is starting with initial conditions
! from dist_init

logical, parameter      :: random_ic   = .false.
logical, parameter      :: grid_ic     = .false.
logical, parameter      :: pairwise_ic = .false. 
logical, parameter      :: pair_infall = .false.
logical, parameter      :: pair_infall_no_shake = .false.
logical, parameter      :: pp_test     = .false.
logical, parameter      :: shake_test_ic = .false.
logical, parameter      :: superposition_test = .false.
real, parameter         :: pair_infall_mass = 1000
real, parameter         :: pair_infall_sep  = 2.0
real, parameter         :: min_sep=0.0 !10
real, parameter         :: max_sep=40!3.0 !20 !nf_buf !2.0 !1
real, parameter         :: sep_inc=0.1

!! particle-particle interaction parameters

! softening length (if (|r1-r2| < rsoft) then no force)
real(4), parameter      :: rsoft = 0.1 !0.02
! arbitrary timescale limiting parameter :: dt_max_pp=sqrt(dt_pp_scale*rsoft/max_pp_acceleration)
real(4), parameter      :: dt_pp_scale = 0.05
! arbitrary pp bias (set to increase the force interaction)
real(4), parameter      :: pp_bias = 1.00 !0.85 !0.1 !0.4642

! testing flags

logical, parameter :: ngp_fmesh_force = .true. 
logical, parameter :: pp_force_flag = .true.!.true.
logical, parameter :: pp_ext_force_flag = .true.!.true.
logical, parameter :: coarse_vel_update = .true.!.true.

logical, parameter :: PID_flag = .true.

! Number of fine cell layers, for extended pp force calculation:
integer(4), parameter   :: pp_range = 2

!! additional simulation analysis

! set this .true. to generate coarse mesh mass power spectrum each timestep

logical, parameter      :: coarse_ps = .false. !.true. ! .false.

! halo finding parameters 

! write out entire halo catalog, or just the value of nhalo

logical, parameter      :: halo_write = .true.

! spherical overdensity cutoff for determining halo extent

real(4), parameter      :: halo_odc=178.0
real(4), parameter      :: halo_nondim_mass=53.92 !nondim. mass corresponding
                                                  !to this overdensity
						  !according to TIS+1/r^2
						  !model. Look into
						  !'table_M_Delta.dat' to
						  !determine for a different
						  !overdensity.
real(4)		        :: actual_odc				 

! lower density peak threshold for determining which peaks should be inspected
! as halos

real(4), parameter      :: den_peak_cutoff = 100.0  

! lower mass cutoff for cataloging a halo, in particles

real(4), parameter      :: min_halo_particles = 100 !20.0

! set .true. to use parabolic interpolation for halo centers, otherwise
! nearest grid point is used

logical, parameter      :: para_inter_hc = .true.

! set .true. to limit initial halo mass calculation to exiting after only
! completing an entire radial shell

logical, parameter      :: complete_shell = .true.

! these are internal and should not be modified

integer(4), parameter   :: nc_halo_max = 128 !32
integer(4), parameter   :: nlist=(nc_halo_max+1)**3*5
integer(4), parameter   :: max_maxima= 5*nc_halo_max**3

!! physical constants

real(4), parameter :: pi = 3.141592654
real(4), parameter :: G = 1.0 / 6.0 / pi
real(4), parameter :: eps = 1.0e-03

! :: internal parameters

logical, parameter :: forward = .true.
logical, parameter :: backward= .false.

integer(4), parameter   :: mesh_scale = 4
integer(4), parameter   :: coarsened_velocity_scale = mesh_scale
!integer(4), parameter   :: fine_clumping_scale = 8
integer(4), parameter   :: fine_clumping_scale = mesh_scale!*finer_halo_grid 
				!this makes velocity and fine clumping 
	                        !coarse output at the same resolution as 
                                !the coarse mesh cic density field

integer(4), parameter   :: coarsest_scale = 4 !by what factor to coarsen the output 
                                              !down from the coarse grid resolution


	
integer(4), parameter :: max_np = density_buffer * ( ((nf_tile-2*nf_buf)*tiles_node_dim/2)**3 + &
                                  (8*nf_buf**3 + 6*nf_buf*(((nf_tile-2*nf_buf)*tiles_node_dim)**2) + &
                                  12*(nf_buf**2)*((nf_tile-2*nf_buf)*tiles_node_dim))/8.0 )

integer(4), parameter   :: max_buf = 2 * max_np  !+ (nf_tile/2)**3 
integer(4), parameter   :: max_tag = max_np / 10

! this can probably be decreased like mega
!integer(4), parameter :: max_llf = ( (nf_tile * tiles_node_dim) / 2 )**2 / mesh_scale 
!integer(4), parameter :: max_llf = 120*( (nf_tile * tiles_node_dim) / 2 )**2 / mesh_scale 
integer(4), parameter :: max_llf = 100000 

integer(4), parameter   :: max_input = 100
integer(4), parameter   :: max_path = 512

integer(4), parameter   :: nodes = nodes_dim * nodes_dim * nodes_dim
integer(4), parameter   :: tiles_node = tiles_node_dim * tiles_node_dim &
                                      * tiles_node_dim

integer(4), parameter   :: nc_buf = nf_buf / mesh_scale

integer(4), parameter   :: nc_tile_dim = ( nf_tile - 2 * nf_buf ) / mesh_scale
integer(4), parameter   :: nc_node_dim = nc_tile_dim * tiles_node_dim
integer(4), parameter   :: nc_dim = nc_node_dim * nodes_dim

integer(4), parameter   :: nodes_slab = nodes_dim * nodes_dim
integer(4), parameter   :: nc_slab = nc_dim / nodes

integer(4), parameter   :: nf_physical_tile_dim = nf_tile - 2 * nf_buf
integer(4), parameter   :: nf_physical_dim = nf_physical_tile_dim &
                                           * tiles_node_dim * nodes_dim
integer(4), parameter   :: nf_physical_node_dim = nf_physical_tile_dim &
                                                * tiles_node_dim

integer(4), parameter   :: hoc_nc_l = 1 - nc_buf
integer(4), parameter   :: hoc_nc_h = nc_node_dim &
                                    + nc_buf
integer(4), parameter   :: hoc_pass_depth = 2 * nc_buf

!real(4), dimension(3,nc_dim+2,nc_dim,nc_slab)                           :: tmp_kern_c
